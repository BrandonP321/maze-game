{"version":3,"sources":["components/Maze/mobileControls.ts","components/Maze/index.tsx","components/Modal/index.tsx","pages/Game/index.tsx","pages/Home/index.tsx","App.tsx","reportWebVitals.ts","index.tsx"],"names":["isSwiping","startPosition","handleScreenTouch","e","position","x","changedTouches","pageX","y","pageY","handleSwipe","Maze","setShowModal","difficulty","useParams","useState","mazeWidth","mazeCells","setMazeCellsState","mazeCellsRef","useRef","row","col","playerLocation","setPlayerLocationState","playerLocationRef","setPlayerLocation","data","current","playerIcon","useEffect","generateCells","window","addEventListener","handleKeyPress","document","directionToMove","slope","handleScreenTouchEnd","moveUp","moveDown","moveRight","moveLeft","nums","i","cellObj","isStart","isEnd","isBottomRow","isRightCol","isLeftCol","isTopRow","push","createPath","cells","validMoves","remainingMoves","right","down","left","up","visitedCells","currentIndex","loopLimit","hasReachedEnd","nextMoves","currentCell","move","nextCell","hasBeenVisited","randomMove","Math","floor","random","length","generateWeightedRandomMove","canMoveUp","canMoveDown","canMoveRight","canMoveLeft","shift","endCellIndex","endCell","cellAboveEnd","possibleMoves","weightedArr","movesCount","Array","fill","key","toLowerCase","getCellByLocation","location","cellIndex","cell","className","ref","style","top","width","height","map","Modal","show","history","useHistory","onClick","go","to","Game","showModal","Home","App","basename","exact","path","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","getElementById"],"mappings":"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","file":"static/js/main.3e17d41d.chunk.js","sourcesContent":["import React from 'react'\r\nimport { isIfStatement } from 'typescript';\r\n\r\nlet isSwiping = false;\r\nlet startPosition: (null | { x: number; y: number }) = null;\r\n\r\n// when user first touches screen\r\nexport const handleScreenTouch = (e: TouchEvent) => {\r\n    let position = {\r\n        x: e.changedTouches[0].pageX,\r\n        y: e.changedTouches[0].pageY,\r\n    }\r\n    startPosition = position;\r\n}\r\n\r\n// when user is moving their finger on the screen\r\nexport const handleSwipe = (e: TouchEvent) => {\r\n    isSwiping = true;\r\n}\r\n\r\n// when user takes their finger off the screen\r\nexport const handleScreenTouchEnd = (e: TouchEvent) => {\r\n    const position = {\r\n        x: e.changedTouches[0].pageX,\r\n        y: e.changedTouches[0].pageY\r\n    }\r\n    // if use wasn't swiping, return false\r\n    if (!isSwiping || !startPosition) return false\r\n\r\n    // calculating slope looks different due to smaller y values being at top of page\r\n    const slope = (position.y - startPosition.y) / (startPosition.x - position.x)\r\n    \r\n    isSwiping = false\r\n\r\n    if (slope <= -1 || slope >= 1) {\r\n        if (position.y < startPosition.y) return 'up'\r\n        else return 'down'\r\n    } else {\r\n        if (position.x > startPosition.x) return 'right'\r\n        else return 'left'\r\n    }\r\n\r\n}\r\n","import React, { ReactElement, useState, useEffect, useRef } from 'react';\r\nimport { useParams } from 'react-router';\r\nimport { transpileModule } from 'typescript';\r\nimport './index.scss';\r\nimport { handleScreenTouch, handleScreenTouchEnd, handleSwipe } from './mobileControls'\r\n\r\n\r\ninterface Props {\r\n    setShowModal: (bool: boolean) => void;\r\n}\r\n\r\ninterface cellPositionProperties {\r\n    isStart: boolean;\r\n    isEnd: boolean;\r\n    isTopRow: boolean;\r\n    isBottomRow: boolean;\r\n    isLeftCol: boolean;\r\n    isRightCol: boolean;\r\n}\r\n\r\ninterface cellMoveProperties {\r\n    canMoveUp: boolean;\r\n    canMoveRight: boolean;\r\n    canMoveDown: boolean;\r\n    canMoveLeft: boolean;\r\n}\r\n\r\ninterface cellProperties extends cellPositionProperties {\r\n}\r\n\r\nexport default function Maze({ setShowModal }: Props): ReactElement {\r\n    const { difficulty } = useParams<any>()\r\n\r\n    const [mazeWidth, setMazeWidth] = useState<number>(difficulty === 'easy' ? 10 : difficulty === 'medium' ? 20 : 30); // height is same as width\r\n    const [mazeCells, setMazeCellsState] = useState<any[]>([]);\r\n    const mazeCellsRef = useRef<any[]>([])\r\n    const setMazeCells = (data: any) => {\r\n        mazeCellsRef.current = data;\r\n        setMazeCellsState(data);\r\n    }\r\n\r\n    const [playerLocation, setPlayerLocationState] = useState<{ row: number; col: number }>({ row: 1, col: 1 })\r\n    const playerLocationRef = useRef<{ row: number; col: number }>({ row: 1, col: 1 })\r\n    const setPlayerLocation = (data: { row: number, col: number }) => {\r\n        playerLocationRef.current = data;\r\n        setPlayerLocationState(data);\r\n    }\r\n\r\n    const playerIcon = useRef<null | HTMLDivElement>(null);\r\n\r\n    useEffect(() => {\r\n        generateCells();\r\n\r\n        // create event listener to move player\r\n        window.addEventListener('keydown', handleKeyPress)\r\n\r\n        // create event listener for when user swipes screen on mobile device\r\n        document.addEventListener('touchstart', handleScreenTouch)\r\n        document.addEventListener('touchmove', handleSwipe)\r\n        document.addEventListener('touchend', e => {\r\n            const directionToMove = handleScreenTouchEnd(e)\r\n\r\n            if (!directionToMove) return\r\n\r\n            switch (directionToMove) {\r\n                case 'up':\r\n                    moveUp();\r\n                    break;\r\n                case 'down':\r\n                    moveDown();\r\n                    break;\r\n                case \"right\":\r\n                    moveRight();\r\n                    break;\r\n                case 'left':\r\n                    moveLeft();\r\n                    break;\r\n            }\r\n        })\r\n    }, [])\r\n\r\n    useEffect(() => {\r\n        // check if player has reached end when they move\r\n        if (playerLocation.col === mazeWidth && playerLocation.row === mazeWidth) {\r\n            setShowModal(true);\r\n        }\r\n    }, [playerLocation])\r\n\r\n    const generateCells: () => void = () => {\r\n\r\n        let nums: cellPositionProperties[] = [];\r\n\r\n        // iterate over all cells in maze\r\n        for (let i = 1; i <= mazeWidth ** 2; i++) {\r\n            const cellObj: cellPositionProperties = {\r\n                isStart: i === 1,\r\n                isEnd: i === mazeWidth ** 2,\r\n                isBottomRow: i > mazeWidth ** 2 - mazeWidth,\r\n                isRightCol: i % mazeWidth === 0,\r\n                isLeftCol: i === 1 || (i - 1) % mazeWidth === 0,\r\n                isTopRow: i <= mazeWidth\r\n            }\r\n\r\n            // push object for cell to array of cells\r\n            nums.push(cellObj);\r\n        }\r\n\r\n        // createSimplePath(nums)\r\n        // createRandomSimplePath(nums)\r\n        // createSimpleLeftAndUpPath(nums);\r\n        // createPathWithoutVisitingCellsTwice(nums);\r\n        createPath(nums);\r\n\r\n        setMazeCells(nums)\r\n    }\r\n\r\n    // simple path to understand logic of game and test user movements\r\n    const createSimplePath = (cells: any[]) => {\r\n        cells.forEach((cell, index) => {\r\n            const cellNumb = index + 1;\r\n\r\n            if (cell.isTopRow) {\r\n                if (!cell.isRightCol) cell.canMoveRight = true;\r\n                if (!cell.isStart) cell.canMoveLeft = true;\r\n            }\r\n            if (cell.isRightCol) {\r\n                if (!cell.isEnd) cell.canMoveDown = true;\r\n                if (!cell.isTopRow) cell.canMoveUp = true;\r\n            }\r\n        })\r\n    }\r\n\r\n    const createRandomSimplePath = (cells: any[]) => {\r\n        const totalMoves = []\r\n        // push total number of right and down moves needed to reach end\r\n        for (let i = 0; i < mazeWidth - 1; i++) {\r\n            totalMoves.push('right');\r\n            totalMoves.push('down')\r\n        }\r\n\r\n        let currentCellIndex = 0;\r\n\r\n        while (totalMoves.length > 0) {\r\n            const currentCell = cells[currentCellIndex];\r\n\r\n            const randomIndex = Math.floor(Math.random() * totalMoves.length)\r\n\r\n            const move = totalMoves[randomIndex]\r\n            totalMoves.splice(randomIndex, 1);\r\n\r\n            switch (move) {\r\n                case 'right':\r\n                    currentCell.canMoveRight = true;\r\n                    currentCellIndex += 1;\r\n                    cells[currentCellIndex].canMoveLeft = true;\r\n                    break;\r\n                case 'down':\r\n                    currentCell.canMoveDown = true;\r\n                    currentCellIndex += mazeWidth;\r\n                    cells[currentCellIndex].canMoveUp = true;\r\n                    break;\r\n            }\r\n        }\r\n    }\r\n\r\n    // implements left and up moves but won't likely reach end\r\n    const createSimpleLeftAndUpPath = (cells: any[]) => {\r\n        const totalMoves = []\r\n        // push total number of right and down moves needed to reach end\r\n        for (let i = 0; i < mazeWidth - 1; i++) {\r\n            totalMoves.push('right');\r\n            totalMoves.push('down')\r\n        }\r\n        console.log(totalMoves)\r\n\r\n        let currentCellIndex = 0;\r\n\r\n        for (let i = 0; i < (mazeWidth ** 2 - 2); i++) {\r\n            const currentCell = cells[currentCellIndex];\r\n\r\n            const randomIndex = Math.floor(Math.random() * totalMoves.length)\r\n\r\n            const move = totalMoves[randomIndex]\r\n            totalMoves.splice(randomIndex, 1);\r\n\r\n            switch (move) {\r\n                case 'right':\r\n                    currentCell.canMoveRight = true;\r\n                    currentCellIndex += 1;\r\n                    cells[currentCellIndex].canMoveLeft = true;\r\n                    totalMoves.push('left') // push opposite move to array of moves\r\n                    break;\r\n                case 'down':\r\n                    currentCell.canMoveDown = true;\r\n                    currentCellIndex += mazeWidth;\r\n                    cells[currentCellIndex].canMoveUp = true;\r\n                    totalMoves.push('up')\r\n                    break;\r\n                case 'up':\r\n                    currentCell.canMoveUp = true;\r\n                    currentCellIndex -= mazeWidth;\r\n                    cells[currentCellIndex].canMoveDown = true;\r\n                    totalMoves.push('down')\r\n                    break;\r\n                case 'left':\r\n                    currentCell.canMoveLeft = true;\r\n                    currentCellIndex -= 1;\r\n                    cells[currentCellIndex].canMoveRight = true;\r\n                    totalMoves.push('right')\r\n                    break;\r\n            }\r\n        }\r\n    }\r\n\r\n    // this path avoids visiting the same cell twice\r\n    const createPathWithoutVisitingCellsTwice = (cells: any[]) => {\r\n        const validMoves = ['up', 'down', 'left', 'right'];\r\n\r\n        const remainingMoves = {\r\n            right: mazeWidth - 1,\r\n            down: mazeWidth - 1,\r\n            left: 0,\r\n            up: 0\r\n        }\r\n\r\n\r\n        let currentIndex = 0;\r\n\r\n        // iterate over cells' upper limit of all cells minus start and end\r\n        for (let i = 0; i < (mazeWidth ** 2 - 2); i++) {\r\n            const nextMoves = [] // valid moves for each iteration\r\n            let currentCell = cells[currentIndex]\r\n\r\n            // for each valid move (up down left and right) check if the move is valid\r\n            for (let move of validMoves) {\r\n                let nextCell = null;\r\n\r\n                switch (move) {\r\n                    case 'up':\r\n                        if (!currentCell.isTopRow) nextCell = cells[currentIndex - mazeWidth];\r\n                        break;\r\n                    case 'right':\r\n                        if (!currentCell.isRightCol) nextCell = cells[currentIndex + 1];\r\n                        break;\r\n                    case 'down':\r\n                        if (!currentCell.isBottomRow) nextCell = cells[currentIndex + mazeWidth];\r\n                        break;\r\n                    case 'left':\r\n                        if (!currentCell.isLeftCol) nextCell = cells[currentIndex - 1];\r\n                        break;\r\n                }\r\n\r\n                // if there is a cell in that direction that hasn't been visited\r\n                if (nextCell && !nextCell.hasBeenVisited) {\r\n                    // add that direction as a valid next move\r\n                    nextMoves.push(move);\r\n                }\r\n            }\r\n\r\n            // randomly choose one of the valid directions to move\r\n            const randomInt = Math.floor(Math.random() * nextMoves.length)\r\n            const randomMove = nextMoves[randomInt];\r\n\r\n\r\n            // if there are no possible moves, break out of for loop since there is nowhere left to go\r\n            if (nextMoves.length === 0) break;\r\n\r\n            // update cell's direction properties and move on to that cell\r\n            switch (randomMove) {\r\n                case 'up':\r\n                    currentCell.canMoveUp = true;\r\n                    currentIndex -= mazeWidth;\r\n                    cells[currentIndex].canMoveDown = true;\r\n                    remainingMoves.up--;\r\n                    remainingMoves.down++;\r\n                    break;\r\n                case 'right':\r\n                    currentCell.canMoveRight = true;\r\n                    currentIndex += 1;\r\n                    cells[currentIndex].canMoveLeft = true;\r\n                    remainingMoves.right--;\r\n                    remainingMoves.left++;\r\n                    break;\r\n                case 'down':\r\n                    currentCell.canMoveDown = true;\r\n                    currentIndex += mazeWidth;\r\n                    cells[currentIndex].canMoveUp = true;\r\n                    remainingMoves.down--;\r\n                    remainingMoves.up++;\r\n                    break;\r\n                case 'left':\r\n                    currentCell.canMoveLeft = true;\r\n                    currentIndex -= 1;\r\n                    cells[currentIndex].canMoveRight = true;\r\n                    remainingMoves.left--;\r\n                    remainingMoves.right++;\r\n                    break;\r\n            }\r\n\r\n            currentCell.hasBeenVisited = true;\r\n            console.log('iteration over')\r\n        }\r\n    }\r\n\r\n    // create path from start cell to end cell\r\n    const createPath = (cells: any[]) => {\r\n        const validMoves = ['up', 'down', 'left', 'right'];\r\n\r\n        const remainingMoves = {\r\n            right: mazeWidth - 1,\r\n            down: mazeWidth - 1,\r\n            left: 0,\r\n            up: 0\r\n        }\r\n\r\n        const visitedCells: number[] = []\r\n\r\n        let currentIndex: any = 0;\r\n\r\n        let loopLimit = mazeWidth ** 2 - 2\r\n\r\n        let hasReachedEnd = false;\r\n\r\n        // iterate over cells' upper limit of all cells minus start and end\r\n        for (let i = 0; i < loopLimit; i++) {\r\n            const nextMoves = [] // valid moves for each iteration\r\n            let currentCell = cells[currentIndex]\r\n\r\n            // for each valid move (up down left and right) check if the move is valid\r\n            for (let move of validMoves) {\r\n                let nextCell = null;\r\n\r\n                // if we are in the end cell, don't create path from here\r\n                if (currentCell.isEnd) {\r\n                    hasReachedEnd = true;\r\n                    break;\r\n                }\r\n\r\n                switch (move) {\r\n                    case 'up':\r\n                        if (!currentCell.isTopRow) nextCell = cells[currentIndex - mazeWidth];\r\n                        break;\r\n                    case 'right':\r\n                        if (!currentCell.isRightCol) nextCell = cells[currentIndex + 1];\r\n                        break;\r\n                    case 'down':\r\n                        if (!currentCell.isBottomRow) nextCell = cells[currentIndex + mazeWidth];\r\n                        break;\r\n                    case 'left':\r\n                        if (!currentCell.isLeftCol) nextCell = cells[currentIndex - 1];\r\n                        break;\r\n                }\r\n\r\n                // if there is a cell in that direction that hasn't been visited\r\n                if (nextCell && !nextCell.hasBeenVisited) {\r\n                    // add that direction as a valid next move\r\n                    nextMoves.push(move);\r\n                }\r\n            }\r\n            \r\n            let randomMove;\r\n            // if user has reached end\r\n            if (hasReachedEnd) {\r\n                // generate completely random direction to move\r\n                const randomInt = Math.floor(Math.random() * nextMoves.length)\r\n                randomMove = nextMoves[randomInt]\r\n            } else {\r\n                // generate weighted random direction to move\r\n                randomMove = generateWeightedRandomMove(remainingMoves, nextMoves) // generates move based on weighted object of moves needed\r\n            }\r\n            \r\n            currentCell.hasBeenVisited = true;\r\n            // if there are no possible moves\r\n            if (nextMoves.length === 0) {\r\n                // move backwards in array of visited cells\r\n                currentIndex = visitedCells.shift();\r\n                loopLimit++\r\n                continue\r\n            }\r\n\r\n            // update cell's direction properties and move on to that cell\r\n            switch (randomMove) {\r\n                case 'up':\r\n                    currentCell.canMoveUp = true;\r\n                    currentIndex -= mazeWidth;\r\n                    cells[currentIndex].canMoveDown = true;\r\n                    remainingMoves.up--;\r\n                    remainingMoves.down++;\r\n                    break;\r\n                case 'right':\r\n                    currentCell.canMoveRight = true;\r\n                    currentIndex += 1;\r\n                    cells[currentIndex].canMoveLeft = true;\r\n                    remainingMoves.right--;\r\n                    remainingMoves.left++;\r\n                    break;\r\n                case 'down':\r\n                    currentCell.canMoveDown = true;\r\n                    currentIndex += mazeWidth;\r\n                    cells[currentIndex].canMoveUp = true;\r\n                    remainingMoves.down--;\r\n                    remainingMoves.up++;\r\n                    break;\r\n                case 'left':\r\n                    currentCell.canMoveLeft = true;\r\n                    currentIndex -= 1;\r\n                    cells[currentIndex].canMoveRight = true;\r\n                    remainingMoves.left--;\r\n                    remainingMoves.right++;\r\n                    break;\r\n            }\r\n\r\n\r\n            visitedCells.push(currentIndex);\r\n        }\r\n\r\n        // if end cell has not been visited, remove border above it to create a valid path\r\n        if (!hasReachedEnd) {\r\n            const endCellIndex = mazeWidth ** 2 - 1\r\n            const endCell = cells[endCellIndex];\r\n            const cellAboveEnd = cells[endCellIndex - mazeWidth];\r\n            endCell.canMoveUp = true;\r\n            cellAboveEnd.canMoveDown = true;\r\n        }\r\n    }\r\n\r\n    \r\n    const generateWeightedRandomMove = (remainingMoves: any, possibleMoves: any[]) => {\r\n        let weightedArr = []\r\n        \r\n        for (let move of possibleMoves) {\r\n            // in the case that the remaining moves object has a value of 0, default that to 1\r\n            let movesCount = remainingMoves[move] === 0 ? 1 : remainingMoves\r\n\r\n            weightedArr.push(...new Array(movesCount).fill(move))\r\n        }\r\n        \r\n        // generate random index in weighted array\r\n        const randomInt = Math.floor(Math.random() * weightedArr.length);\r\n        return weightedArr[randomInt]\r\n    }\r\n    \r\n    const handleKeyPress = (e: KeyboardEvent) => {\r\n        // return early if player icon has not been loaded in yet\r\n        if (!playerIcon) return\r\n\r\n        switch (e.key.toLowerCase()) {\r\n            case 'w':\r\n            case 'arrowup':\r\n                moveUp();\r\n                break;\r\n            case 'a':\r\n            case 'arrowleft':\r\n                moveLeft();\r\n                break;\r\n            case 's':\r\n            case 'arrowdown':\r\n                moveDown();\r\n                break;\r\n            case \"d\":\r\n            case \"arrowright\":\r\n                moveRight();\r\n                break;\r\n        }\r\n    }\r\n\r\n    const getCellByLocation = (location: { row: number, col: number }) => {\r\n        const cellIndex = (location.row - 1) * mazeWidth + location.col - 1\r\n        return mazeCellsRef.current[cellIndex];\r\n    }\r\n\r\n    const moveUp = () => {\r\n        const cell = getCellByLocation(playerLocationRef.current)\r\n\r\n        if (playerLocationRef.current.row === 1 || !cell.canMoveUp) return\r\n\r\n        setPlayerLocation({ ...playerLocationRef.current, row: playerLocationRef.current.row - 1 })\r\n    }\r\n\r\n    const moveRight = () => {\r\n        const cell = getCellByLocation(playerLocationRef.current)\r\n\r\n        if (playerLocationRef.current.col >= mazeWidth || !cell.canMoveRight) return\r\n\r\n        setPlayerLocation({ ...playerLocationRef.current, col: playerLocationRef.current.col + 1 })\r\n    }\r\n\r\n    const moveLeft = () => {\r\n        const cell = getCellByLocation(playerLocationRef.current)\r\n\r\n        if (playerLocationRef.current.col === 1 || !cell.canMoveLeft) return\r\n\r\n        setPlayerLocation({ ...playerLocationRef.current, col: playerLocationRef.current.col - 1 })\r\n    }\r\n\r\n    const moveDown = () => {\r\n        const cell = getCellByLocation(playerLocationRef.current)\r\n\r\n        if (playerLocationRef.current.row >= mazeWidth || !cell.canMoveDown) return\r\n\r\n        setPlayerLocation({ ...playerLocationRef.current, row: playerLocationRef.current.row + 1 })\r\n    }\r\n\r\n    return (\r\n        <div className='maze-aspect-ratio-wrapper'>\r\n            <div className='maze-wrapper-outer'>\r\n                <div className='maze-wrapper-inner'>\r\n                    <div\r\n                        ref={playerIcon}\r\n                        className='player-wrapper'\r\n                        style={{ top: `${(playerLocation.row - 1) * (100 / mazeWidth)}%`, left: `${(playerLocation.col - 1) * (100 / mazeWidth)}%`, width: `${100 / mazeWidth}%`, height: `${100 / mazeWidth}%` }}>\r\n                        <div className='player'></div>\r\n                    </div>\r\n                    {mazeCells.map((cell, i) => {\r\n                        return (\r\n                            <div\r\n                                className={`maze-cell${cell.isStart ? ' start' : ''}${cell.isEnd ? ' end' : ''}${cell.isRightCol ? ' right-col' : ''}${cell.isBottomRow ? ' bottom-row' : ''}${cell.canMoveUp ? ' can-move-up' : ''}${cell.canMoveRight ? ' can-move-right' : ''}${cell.canMoveDown ? ' can-move-down' : ''}${cell.canMoveLeft ? ' can-move-left' : ''}`}\r\n                                style={{ width: `${100 / mazeWidth}%`, height: `${100 / mazeWidth}%` }}\r\n                                key={i}>\r\n                            </div>\r\n                        )\r\n                    })}\r\n                </div>\r\n            </div>\r\n        </div>\r\n    )\r\n}\r\n","import React, { ReactElement } from 'react'\r\nimport { Link, useHistory } from 'react-router-dom'\r\nimport './index.scss'\r\n\r\ninterface Props {\r\n    show: boolean;\r\n}\r\n\r\nexport default function Modal({ show }: Props): ReactElement {\r\n    let history = useHistory();\r\n\r\n    return (\r\n        <>\r\n            <div className={`maze-modal${show ? ' show' : ''}`}>\r\n                <h1>You Win!</h1>\r\n                <div className='buttons'>\r\n                    <button onClick={() => history.go(0)}>Play Again</button>\r\n                    <Link to='/'>Home</Link>\r\n                </div>\r\n            </div>\r\n            <div className={`modal-page-overlay${show ? ' show' : ''}`}></div>\r\n        </>\r\n    )\r\n}\r\n","import React, { ReactElement, useState } from 'react'\r\nimport Maze from '../../components/Maze'\r\nimport Modal from '../../components/Modal'\r\nimport './index.css'\r\n\r\nexport default function Game(): ReactElement {\r\n    const [showModal, setShowModal] = useState<boolean>(false)\r\n\r\n    return (\r\n        <>\r\n            <Maze setShowModal={setShowModal}/>\r\n            <Modal show={showModal}/>\r\n        </>\r\n    )\r\n}\r\n","import React, { ReactElement } from 'react'\r\nimport { Link } from 'react-router-dom'\r\nimport './index.scss'\r\n\r\ninterface Props {\r\n    \r\n}\r\n\r\nexport default function Home({}: Props): ReactElement {\r\n    return (\r\n        <div className='home-page'>\r\n            <h1>The Maze Game</h1>\r\n            <div className='buttons'>\r\n                <Link to='/game/easy'>Easy</Link>\r\n                <Link to='/game/medium'>Medium</Link>\r\n                <Link to='/game/hard'>Hard</Link>\r\n            </div>\r\n        </div >\r\n    )\r\n}\r\n","import React from 'react';\r\nimport './App.css';\r\nimport { BrowserRouter as Router, Switch, Route } from 'react-router-dom';\r\nimport Game from './pages/Game';\r\nimport Home from './pages/Home';\r\n\r\nfunction App() {\r\n  return (\r\n    <div className=\"App\">\r\n      <Router basename='/maze-game'>\r\n        <Switch>\r\n          <Route exact path='/'>\r\n            <Home />\r\n          </Route>\r\n          <Route exact path='/game/:difficulty'>\r\n            <Game />\r\n          </Route>\r\n        </Switch>\r\n      </Router>\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default App;\r\n","import { ReportHandler } from 'web-vitals';\n\nconst reportWebVitals = (onPerfEntry?: ReportHandler) => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}