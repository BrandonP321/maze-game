{"version":3,"sources":["components/Maze/mobileControls.ts","components/Maze/index.tsx","components/Modal/index.tsx","pages/Game/index.tsx","pages/Home/index.tsx","App.tsx","reportWebVitals.ts","index.tsx"],"names":["isSwiping","startPosition","handleScreenTouch","e","position","x","changedTouches","pageX","y","pageY","handleSwipe","Maze","setShowModal","difficulty","useParams","useState","mazeWidth","mazeCells","setMazeCellsState","mazeCellsRef","useRef","row","col","playerLocation","setPlayerLocationState","playerLocationRef","setPlayerLocation","data","current","playerIcon","useEffect","generateCells","window","addEventListener","handleKeyPress","document","directionToMove","slope","handleScreenTouchEnd","moveUp","moveDown","moveRight","moveLeft","cells","i","cellObj","isStart","isEnd","isBottomRow","isRightCol","isLeftCol","isTopRow","push","createPath","validMoves","remainingMoves","right","down","left","up","visitedCells","currentCellIndex","loopLimit","hasReachedEnd","nextMoves","currentCell","move","nextCell","hasBeenVisited","randomMove","Math","floor","random","length","generateWeightedRandomMove","canMoveUp","canMoveDown","canMoveRight","canMoveLeft","shift","endCellIndex","endCell","cellAboveEnd","possibleMoves","weightedArr","movesCount","Array","fill","key","toLowerCase","getCellByLocation","location","cellIndex","cell","className","ref","style","top","width","height","map","Modal","show","history","useHistory","onClick","go","to","Game","showModal","Home","href","App","basename","exact","path","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","getElementById"],"mappings":"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","file":"static/js/main.a78438f8.chunk.js","sourcesContent":["import React from 'react'\r\nimport { isIfStatement } from 'typescript';\r\n\r\nlet isSwiping = false;\r\nlet startPosition: (null | { x: number; y: number }) = null;\r\n\r\n// when user first touches screen\r\nexport const handleScreenTouch = (e: TouchEvent) => {\r\n    // get position of where they touched\r\n    let position = {\r\n        x: e.changedTouches[0].pageX,\r\n        y: e.changedTouches[0].pageY,\r\n    }\r\n    startPosition = position;\r\n}\r\n\r\n// when user is moving their finger on the screen\r\nexport const handleSwipe = (e: TouchEvent) => {\r\n    isSwiping = true;\r\n}\r\n\r\n// when user takes their finger off the screen\r\nexport const handleScreenTouchEnd = (e: TouchEvent) => {\r\n    // get position where they let go of the screen\r\n    const position = {\r\n        x: e.changedTouches[0].pageX,\r\n        y: e.changedTouches[0].pageY\r\n    }\r\n    // if user wasn't swiping, return false\r\n    if (!isSwiping || !startPosition) return false\r\n\r\n    // calculating slope might look different due to smaller y values being at top of page (like an upside down graph)\r\n    const slope = (position.y - startPosition.y) / (startPosition.x - position.x)\r\n    \r\n    isSwiping = false\r\n\r\n    // return appropriate direction user wants to move\r\n    if (slope <= -1 || slope >= 1) {\r\n        if (position.y < startPosition.y) return 'up'\r\n        else return 'down'\r\n    } else {\r\n        if (position.x > startPosition.x) return 'right'\r\n        else return 'left'\r\n    }\r\n\r\n}\r\n","import React, { ReactElement, useState, useEffect, useRef } from 'react';\r\nimport { useParams } from 'react-router';\r\nimport { transpileModule } from 'typescript';\r\nimport './index.scss';\r\nimport { handleScreenTouch, handleScreenTouchEnd, handleSwipe } from './mobileControls'\r\n\r\n\r\ninterface Props {\r\n    setShowModal: (bool: boolean) => void;\r\n}\r\n\r\ninterface cellProperties {\r\n    isStart?: boolean;\r\n    isEnd?: boolean;\r\n    isTopRow?: boolean;\r\n    isBottomRow?: boolean;\r\n    isLeftCol?: boolean;\r\n    isRightCol?: boolean;\r\n    canMoveUp?: boolean;\r\n    canMoveRight?: boolean;\r\n    canMoveDown?: boolean;\r\n    canMoveLeft?: boolean;\r\n    hasBeenVisited?: boolean;\r\n}\r\n\r\ninterface playerLocation {\r\n    row: number;\r\n    col: number\r\n}\r\n\r\nexport default function Maze({ setShowModal }: Props): ReactElement {\r\n    const { difficulty } = useParams<any>()\r\n\r\n    // set width of maze based on difficulty url parameter\r\n    const [mazeWidth, setMazeWidth] = useState<number>(difficulty === 'easy' ? 10 : difficulty === 'medium' ? 20 : 30); // height is same as width\r\n\r\n    const [mazeCells, setMazeCellsState] = useState<cellProperties[]>([]);\r\n    const mazeCellsRef = useRef<cellProperties[]>([])\r\n    const setMazeCells = (data: cellProperties[]) => {\r\n        mazeCellsRef.current = data;\r\n        setMazeCellsState(data);\r\n    }\r\n\r\n    const [playerLocation, setPlayerLocationState] = useState<playerLocation>({ row: 1, col: 1 })\r\n    const playerLocationRef = useRef<playerLocation>({ row: 1, col: 1 })\r\n    const setPlayerLocation = (data: playerLocation) => {\r\n        playerLocationRef.current = data;\r\n        setPlayerLocationState(data);\r\n    }\r\n\r\n    const playerIcon = useRef<null | HTMLDivElement>(null);\r\n\r\n    useEffect(() => {\r\n        // create maze\r\n        generateCells();\r\n\r\n        // create event listener to move player\r\n        window.addEventListener('keydown', handleKeyPress)\r\n\r\n        // create event listeners for touch screens\r\n        document.addEventListener('touchstart', handleScreenTouch)\r\n        document.addEventListener('touchmove', handleSwipe)\r\n        document.addEventListener('touchend', e => {\r\n            const directionToMove = handleScreenTouchEnd(e)\r\n\r\n            if (!directionToMove) return\r\n\r\n            switch (directionToMove) {\r\n                case 'up':\r\n                    moveUp();\r\n                    break;\r\n                case 'down':\r\n                    moveDown();\r\n                    break;\r\n                case \"right\":\r\n                    moveRight();\r\n                    break;\r\n                case 'left':\r\n                    moveLeft();\r\n                    break;\r\n            }\r\n        })\r\n    }, [])\r\n\r\n    useEffect(() => {\r\n        // check if player has reached end when they move\r\n        if (playerLocation.col === mazeWidth && playerLocation.row === mazeWidth) {\r\n            setShowModal(true);\r\n        }\r\n    }, [playerLocation])\r\n\r\n    const generateCells: () => void = () => {\r\n        let cells: cellProperties[] = [];\r\n\r\n        // iterate over all cells in maze\r\n        for (let i = 1; i <= mazeWidth ** 2; i++) {\r\n            // create object to describe positioning of cell\r\n            const cellObj: cellProperties = {\r\n                isStart: i === 1,\r\n                isEnd: i === mazeWidth ** 2,\r\n                isBottomRow: i > mazeWidth ** 2 - mazeWidth,\r\n                isRightCol: i % mazeWidth === 0,\r\n                isLeftCol: i === 1 || (i - 1) % mazeWidth === 0,\r\n                isTopRow: i <= mazeWidth\r\n            }\r\n\r\n            cells.push(cellObj);\r\n        }\r\n\r\n        // create a path from the start cell to the end cell\r\n        createPath(cells);\r\n\r\n        setMazeCells(cells)\r\n    }\r\n\r\n    // create path from start cell to end cell\r\n    const createPath = (cells: cellProperties[]) => {\r\n        const validMoves = ['up', 'down', 'left', 'right'];\r\n\r\n        // object stores amount of moves that can be made in a given direction (used to make weighted decisions later on)\r\n        const remainingMoves = {\r\n            right: mazeWidth - 1,\r\n            down: mazeWidth - 1,\r\n            left: 0,\r\n            up: 0\r\n        }\r\n\r\n        // cells already part of a path\r\n        const visitedCells: number[] = [] \r\n\r\n        let currentCellIndex: any = 0;\r\n\r\n        // ensures that loop with iterate over every cell except that first and last\r\n        let loopLimit = mazeWidth ** 2 - 2\r\n\r\n        let hasReachedEnd = false;\r\n\r\n        // iterate over cells' upper limit of all cells minus start and end\r\n        for (let i = 0; i < loopLimit; i++) {\r\n            const nextMoves = [] // possible moves for current iteration\r\n            let currentCell = cells[currentCellIndex]\r\n\r\n            // for each valid move (up down left and right) check if the move is valid\r\n            for (let move of validMoves) {\r\n                let nextCell = null;\r\n\r\n                // if we are in the end cell, stop creating a path\r\n                if (currentCell.isEnd) {\r\n                    hasReachedEnd = true;\r\n                    break;\r\n                }\r\n\r\n                switch (move) {\r\n                    case 'up':\r\n                        if (!currentCell.isTopRow) nextCell = cells[currentCellIndex - mazeWidth];\r\n                        break;\r\n                    case 'right':\r\n                        if (!currentCell.isRightCol) nextCell = cells[currentCellIndex + 1];\r\n                        break;\r\n                    case 'down':\r\n                        if (!currentCell.isBottomRow) nextCell = cells[currentCellIndex + mazeWidth];\r\n                        break;\r\n                    case 'left':\r\n                        if (!currentCell.isLeftCol) nextCell = cells[currentCellIndex - 1];\r\n                        break;\r\n                }\r\n\r\n                // if there is a cell in the given direction and it hasn't been visited yet\r\n                if (nextCell && !nextCell.hasBeenVisited) {\r\n                    // add that direction as a valid next move\r\n                    nextMoves.push(move);\r\n                }\r\n            }\r\n\r\n            let randomMove;\r\n            // if path has reached the end cell, the cell we are on now must be some other cell we are building a detour route from\r\n            if (hasReachedEnd) {\r\n                // generate completely random direction to move\r\n                const randomInt = Math.floor(Math.random() * nextMoves.length)\r\n                randomMove = nextMoves[randomInt]\r\n            } else {\r\n                // else generate a weighted random direction to move (we are still working towards the end cell)\r\n                randomMove = generateWeightedRandomMove(remainingMoves, nextMoves) // generates move based on weighted object of moves needed\r\n            }\r\n\r\n            // tell program we have made this cell part of the path\r\n            currentCell.hasBeenVisited = true; \r\n\r\n            // if there are no possible moves\r\n            if (nextMoves.length === 0) {\r\n                // loop through array of visited cells and repeat iterations to create detour routes\r\n                    currentCellIndex = visitedCells.shift();\r\n                // increment loop limit so this iteration essentially doesn't count\r\n                loopLimit++\r\n                continue\r\n            }\r\n\r\n            // update cell's direction properties and move on to the next cell\r\n            switch (randomMove) {\r\n                case 'up':\r\n                    currentCell.canMoveUp = true;\r\n                    currentCellIndex -= mazeWidth;\r\n                    cells[currentCellIndex].canMoveDown = true;\r\n                    remainingMoves.up--;\r\n                    remainingMoves.down++;\r\n                    break;\r\n                case 'right':\r\n                    currentCell.canMoveRight = true;\r\n                    currentCellIndex += 1;\r\n                    cells[currentCellIndex].canMoveLeft = true;\r\n                    remainingMoves.right--;\r\n                    remainingMoves.left++;\r\n                    break;\r\n                case 'down':\r\n                    currentCell.canMoveDown = true;\r\n                    currentCellIndex += mazeWidth;\r\n                    cells[currentCellIndex].canMoveUp = true;\r\n                    remainingMoves.down--;\r\n                    remainingMoves.up++;\r\n                    break;\r\n                case 'left':\r\n                    currentCell.canMoveLeft = true;\r\n                    currentCellIndex -= 1;\r\n                    cells[currentCellIndex].canMoveRight = true;\r\n                    remainingMoves.left--;\r\n                    remainingMoves.right++;\r\n                    break;\r\n            }\r\n\r\n            visitedCells.push(currentCellIndex);\r\n        }\r\n\r\n        // if end cell has not been visited for any reason\r\n        if (!hasReachedEnd) {\r\n            // connect end cell to whatever path is directly above it\r\n            const endCellIndex = mazeWidth ** 2 - 1\r\n            const endCell = cells[endCellIndex];\r\n            const cellAboveEnd = cells[endCellIndex - mazeWidth];\r\n            endCell.canMoveUp = true;\r\n            cellAboveEnd.canMoveDown = true;\r\n        }\r\n    }\r\n\r\n    // returns a direction to move based on a weighted decision\r\n    const generateWeightedRandomMove = (remainingMoves: any, possibleMoves: any[]) => {\r\n        let weightedArr = []\r\n        \r\n        // store each move x amount of times where x is the given count for that move in the remainingMoves obj\r\n        for (let move of possibleMoves) {\r\n            // in the case that the remaining moves object has a value of 0, default that to 1\r\n            let movesCount = remainingMoves[move] === 0 ? 1 : remainingMoves\r\n\r\n            weightedArr.push(...new Array(movesCount).fill(move))\r\n        }\r\n\r\n        // return a random move\r\n        const randomInt = Math.floor(Math.random() * weightedArr.length);\r\n        return weightedArr[randomInt]\r\n    }\r\n\r\n    // event handler for controlling player\r\n    const handleKeyPress = (e: KeyboardEvent) => {\r\n        // return early if player icon has not been loaded in yet\r\n        if (!playerIcon) return\r\n\r\n        switch (e.key.toLowerCase()) {\r\n            case 'w':\r\n            case 'arrowup':\r\n                moveUp();\r\n                break;\r\n            case 'a':\r\n            case 'arrowleft':\r\n                moveLeft();\r\n                break;\r\n            case 's':\r\n            case 'arrowdown':\r\n                moveDown();\r\n                break;\r\n            case \"d\":\r\n            case \"arrowright\":\r\n                moveRight();\r\n                break;\r\n        }\r\n    }\r\n\r\n    const getCellByLocation = (location: playerLocation) => {\r\n        const cellIndex = (location.row - 1) * mazeWidth + location.col - 1\r\n        return mazeCellsRef.current[cellIndex];\r\n    }\r\n\r\n    const moveUp = () => {\r\n        const cell = getCellByLocation(playerLocationRef.current)\r\n\r\n        if (playerLocationRef.current.row === 1 || !cell.canMoveUp) return\r\n\r\n        setPlayerLocation({ ...playerLocationRef.current, row: playerLocationRef.current.row - 1 })\r\n    }\r\n\r\n    const moveRight = () => {\r\n        const cell = getCellByLocation(playerLocationRef.current)\r\n\r\n        if (playerLocationRef.current.col >= mazeWidth || !cell.canMoveRight) return\r\n\r\n        setPlayerLocation({ ...playerLocationRef.current, col: playerLocationRef.current.col + 1 })\r\n    }\r\n\r\n    const moveLeft = () => {\r\n        const cell = getCellByLocation(playerLocationRef.current)\r\n\r\n        if (playerLocationRef.current.col === 1 || !cell.canMoveLeft) return\r\n\r\n        setPlayerLocation({ ...playerLocationRef.current, col: playerLocationRef.current.col - 1 })\r\n    }\r\n\r\n    const moveDown = () => {\r\n        const cell = getCellByLocation(playerLocationRef.current)\r\n\r\n        if (playerLocationRef.current.row >= mazeWidth || !cell.canMoveDown) return\r\n\r\n        setPlayerLocation({ ...playerLocationRef.current, row: playerLocationRef.current.row + 1 })\r\n    }\r\n\r\n    return (\r\n        <div className='maze-aspect-ratio-wrapper'>\r\n            <div className='maze-wrapper-outer'>\r\n                <div className='maze-wrapper-inner'>\r\n                    <div\r\n                        ref={playerIcon}\r\n                        className='player-wrapper'\r\n                        style={{ top: `${(playerLocation.row - 1) * (100 / mazeWidth)}%`, left: `${(playerLocation.col - 1) * (100 / mazeWidth)}%`, width: `${100 / mazeWidth}%`, height: `${100 / mazeWidth}%` }}>\r\n                        <div className='player'></div>\r\n                    </div>\r\n                    {mazeCells.map((cell, i) => {\r\n                        return (\r\n                            <div\r\n                                className={`maze-cell${cell.isStart ? ' start' : ''}${cell.isEnd ? ' end' : ''}${cell.isRightCol ? ' right-col' : ''}${cell.isBottomRow ? ' bottom-row' : ''}${cell.canMoveUp ? ' can-move-up' : ''}${cell.canMoveRight ? ' can-move-right' : ''}${cell.canMoveDown ? ' can-move-down' : ''}${cell.canMoveLeft ? ' can-move-left' : ''}`}\r\n                                style={{ width: `${100 / mazeWidth}%`, height: `${100 / mazeWidth}%` }}\r\n                                key={i}>\r\n                            </div>\r\n                        )\r\n                    })}\r\n                </div>\r\n            </div>\r\n        </div>\r\n    )\r\n}\r\n","import React, { ReactElement } from 'react'\r\nimport { Link, useHistory } from 'react-router-dom'\r\nimport './index.scss'\r\n\r\ninterface Props {\r\n    show: boolean;\r\n}\r\n\r\nexport default function Modal({ show }: Props): ReactElement {\r\n    let history = useHistory();\r\n\r\n    return (\r\n        <>\r\n            <div className={`maze-modal${show ? ' show' : ''}`}>\r\n                <h1>You Win!</h1>\r\n                <div className='buttons'>\r\n                    <button onClick={() => history.go(0)}>Play Again</button>\r\n                    <Link to='/'>Home</Link>\r\n                </div>\r\n            </div>\r\n            <div className={`modal-page-overlay${show ? ' show' : ''}`}></div>\r\n        </>\r\n    )\r\n}\r\n","import React, { ReactElement, useState } from 'react'\r\nimport Maze from '../../components/Maze'\r\nimport Modal from '../../components/Modal'\r\nimport './index.scss'\r\n\r\nexport default function Game(): ReactElement {\r\n    const [showModal, setShowModal] = useState<boolean>(false)\r\n\r\n    return (\r\n        <>\r\n            <Maze setShowModal={setShowModal}/>\r\n            <Modal show={showModal}/>\r\n        </>\r\n    )\r\n}\r\n","import React, { ReactElement } from 'react'\r\nimport './index.scss'\r\n\r\nexport default function Home(): ReactElement {\r\n    return (\r\n        <div className='home-page'>\r\n            <h1>The Maze Game</h1>\r\n            <div className='buttons'>\r\n                <a href='/maze-game/game/easy'>Easy</a>\r\n                <a href='/maze-game/game/medium'>Medium</a>\r\n                <a href='/maze-game/game/hard'>Hard</a>\r\n            </div>\r\n        </div >\r\n    )\r\n}\r\n","import React from 'react';\r\nimport './App.css';\r\nimport { BrowserRouter as Router, Switch, Route } from 'react-router-dom';\r\nimport Game from './pages/Game';\r\nimport Home from './pages/Home';\r\n\r\nfunction App() {\r\n  return (\r\n    <div className=\"App\">\r\n      <Router basename='/maze-game'>\r\n        <Switch>\r\n          <Route exact path='/'>\r\n            <Home />\r\n          </Route>\r\n          <Route exact path='/game/:difficulty'>\r\n            <Game />\r\n          </Route>\r\n        </Switch>\r\n      </Router>\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default App;\r\n","import { ReportHandler } from 'web-vitals';\n\nconst reportWebVitals = (onPerfEntry?: ReportHandler) => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}