{"version":3,"sources":["components/Maze/index.tsx","pages/Game/index.tsx","App.tsx","reportWebVitals.ts","index.tsx"],"names":["Maze","useState","mazeWidth","mazeCells","setMazeCellsState","mazeCellsRef","useRef","row","col","playerLocation","setPlayerLocationState","playerLocationRef","setPlayerLocation","data","current","playerIcon","useEffect","generateCells","window","addEventListener","handleKeyPress","nums","i","cellObj","isStart","isEnd","isBottomRow","isRightCol","isLeftCol","isTopRow","push","createPathWithoutVisitingCellsTwice","cells","validMoves","currentIndex","nextMoves","currentCell","move","nextCell","hasBeenVisited","randomMove","Math","floor","random","length","canMoveUp","console","log","canMoveDown","canMoveRight","canMoveLeft","e","key","toLowerCase","moveUp","moveLeft","moveDown","moveRight","getCellIndexByLocation","location","cellIndex","cell","className","ref","style","top","left","width","height","map","Game","App","basename","exact","path","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"wTA2Be,SAASA,EAAT,GAAyC,qBAClBC,mBAAiB,IADA,mBAC5CC,EAD4C,aAEZD,mBAAgB,KAFJ,mBAE5CE,EAF4C,KAEjCC,EAFiC,KAG7CC,EAAeC,iBAAc,IAHgB,EASFL,mBAAuC,CAAEM,IAAK,EAAGC,IAAK,IATpD,mBAS5CC,EAT4C,KAS5BC,EAT4B,KAU7CC,EAAoBL,iBAAqC,CAAEC,IAAK,EAAGC,IAAK,IACxEI,EAAoB,SAACC,GACvBF,EAAkBG,QAAUD,EAC5BH,EAAuBG,IAGrBE,EAAaT,iBAA8B,MAEjDU,qBAAU,WACNC,IAGAC,OAAOC,iBAAiB,UAAWC,KACpC,IAEH,IAAMH,EAA4B,WAK9B,IAHA,IAvBkBJ,EAuBdQ,EAAiC,GAG5BC,EAAI,EAAGA,GAAC,SAAIpB,EAAa,GAAGoB,IAAK,CACtC,IAAMC,EAAkC,CACpCC,QAAe,IAANF,EACTG,MAAOH,IAAC,SAAKpB,EAAa,GAC1BwB,YAAaJ,EAAI,SAAApB,EAAa,GAAIA,EAClCyB,WAAYL,EAAIpB,IAAc,EAC9B0B,UAAiB,IAANN,IAAYA,EAAI,GAAKpB,IAAc,EAC9C2B,SAAUP,GAAKpB,GAInBmB,EAAKS,KAAKP,GAMdQ,EAAoCV,GA3ClBR,EA6CLQ,EA5CbhB,EAAaS,QAAUD,EACvBT,EAAkBS,IAiJhBkB,EAAsC,SAACC,GAczC,IAbA,IAAMC,EAAa,CAAC,KAAM,OAAQ,OAAQ,SAUtCC,EAAe,EAGVZ,EAAI,EAAGA,EAAK,SAAApB,EAAa,GAAI,EAAIoB,IAAK,CAC3C,IAD2C,EACrCa,EAAY,GACdC,EAAcJ,EAAME,GAFmB,cAM1BD,GAN0B,IAM3C,2BAA6B,CAAC,IAArBI,EAAoB,QACrBC,EAAW,KAEf,OAAQD,GACJ,IAAK,KACID,EAAYP,WAAUS,EAAWN,EAAME,EAAehC,IAC3D,MACJ,IAAK,QACIkC,EAAYT,aAAYW,EAAWN,EAAME,EAAe,IAC7D,MACJ,IAAK,OACIE,EAAYV,cAAaY,EAAWN,EAAME,EAAehC,IAC9D,MACJ,IAAK,OACIkC,EAAYR,YAAWU,EAAWN,EAAME,EAAe,IAKhEI,IAAaA,EAASC,gBAEtBJ,EAAUL,KAAKO,IA3BoB,8BAgC3C,IACMG,EAAaL,EADDM,KAAKC,MAAMD,KAAKE,SAAWR,EAAUS,SAEvD,GAAIT,EAAUS,OAAS,EAEnB,OAAQJ,GACJ,IAAK,KACDJ,EAAYS,WAAY,EACxBX,GAAgBhC,EAChB4C,QAAQC,IAAIb,GACZF,EAAME,GAAcc,aAAc,EAClC,MACJ,IAAK,QACDZ,EAAYa,cAAe,EAE3BjB,EADAE,GAAgB,GACIgB,aAAc,EAClC,MACJ,IAAK,OACDd,EAAYY,aAAc,EAE1BhB,EADAE,GAAgBhC,GACI2C,WAAY,EAChC,MACJ,IAAK,OACDT,EAAYc,aAAc,EAE1BlB,EADAE,GAAgB,GACIe,cAAe,EAK/Cb,EAAYG,gBAAiB,EAC7BO,QAAQC,IAAI,oBAId3B,EAAiB,SAAC+B,GAEpB,GAAKpC,EAEL,OAAQoC,EAAEC,IAAIC,eACV,IAAK,IACL,IAAK,UACDC,IACA,MACJ,IAAK,IACL,IAAK,YACDC,IACA,MACJ,IAAK,IACL,IAAK,YACDC,IACA,MACJ,IAAK,IACL,IAAK,aACDC,MAKNC,EAAyB,SAACC,GAC5B,IAAMC,GAAaD,EAASpD,IAAM,GAAKL,EAAYyD,EAASnD,IAAM,EAClE,OAAOH,EAAaS,QAAQ8C,IAG1BN,EAAS,WACX,IAAMO,EAAOH,EAAuB/C,EAAkBG,SAEhB,IAAlCH,EAAkBG,QAAQP,KAAcsD,EAAKhB,WAEjDjC,EAAkB,2BAAKD,EAAkBG,SAAxB,IAAiCP,IAAKI,EAAkBG,QAAQP,IAAM,MAGrFkD,EAAY,WACd,IAAMI,EAAOH,EAAuB/C,EAAkBG,SAElDH,EAAkBG,QAAQN,KAAON,IAAc2D,EAAKZ,cAExDrC,EAAkB,2BAAKD,EAAkBG,SAAxB,IAAiCN,IAAKG,EAAkBG,QAAQN,IAAM,MAGrF+C,EAAW,WACb,IAAMM,EAAOH,EAAuB/C,EAAkBG,SAEhB,IAAlCH,EAAkBG,QAAQN,KAAcqD,EAAKX,aAEjDtC,EAAkB,2BAAKD,EAAkBG,SAAxB,IAAiCN,IAAKG,EAAkBG,QAAQN,IAAM,MAGrFgD,EAAW,WACb,IAAMK,EAAOH,EAAuB/C,EAAkBG,SAElDH,EAAkBG,QAAQP,KAAOL,IAAc2D,EAAKb,aAExDpC,EAAkB,2BAAKD,EAAkBG,SAAxB,IAAiCP,IAAKI,EAAkBG,QAAQP,IAAM,MAG3F,OACI,qBAAKuD,UAAU,4BAAf,SACI,qBAAKA,UAAU,qBAAf,SACI,sBAAKA,UAAU,qBAAf,UACI,qBACIC,IAAKhD,EACL+C,UAAU,iBACVE,MAAO,CAAEC,IAAI,GAAD,QAAMxD,EAAeF,IAAM,IAAM,IAAML,GAAvC,KAAsDgE,KAAK,GAAD,QAAMzD,EAAeD,IAAM,IAAM,IAAMN,GAAvC,KAAsDiE,MAAM,GAAD,OAAK,IAAMjE,EAAX,KAAyBkE,OAAO,GAAD,OAAK,IAAMlE,EAAX,MAHpK,SAII,qBAAK4D,UAAU,aAElB3D,EAAUkE,KAAI,SAACR,EAAMvC,GAClB,OACI,qBACIwC,UAAS,mBAAcD,EAAKrC,QAAU,SAAW,IAAxC,OAA6CqC,EAAKpC,MAAQ,OAAS,IAAnE,OAAwEoC,EAAKlC,WAAa,aAAe,IAAzG,OAA8GkC,EAAKnC,YAAc,cAAgB,IAAjJ,OAAsJmC,EAAKhB,UAAY,eAAiB,IAAxL,OAA6LgB,EAAKZ,aAAe,kBAAoB,IAArO,OAA0OY,EAAKb,YAAc,iBAAmB,IAAhR,OAAqRa,EAAKX,YAAc,iBAAmB,IACpUc,MAAO,CAAEG,MAAM,GAAD,OAAK,IAAMjE,EAAX,KAAyBkE,OAAO,GAAD,OAAK,IAAMlE,EAAX,OACxCoB,a,MC1UtB,SAASgD,IACpB,OACI,mCACI,cAAC,EAAD,MCYGC,MAdf,WACE,OACE,qBAAKT,UAAU,MAAf,SACE,cAAC,IAAD,CAAQU,SAAS,aAAjB,SACE,cAAC,IAAD,UACE,cAAC,IAAD,CAAOC,OAAK,EAACC,KAAK,IAAlB,SACE,cAAC,EAAD,aCGGC,EAZS,SAACC,GACnBA,GAAeA,aAAuBC,UACxC,6BAAqBC,MAAK,YAAkD,IAA/CC,EAA8C,EAA9CA,OAAQC,EAAsC,EAAtCA,OAAQC,EAA8B,EAA9BA,OAAQC,EAAsB,EAAtBA,OAAQC,EAAc,EAAdA,QAC3DJ,EAAOH,GACPI,EAAOJ,GACPK,EAAOL,GACPM,EAAON,GACPO,EAAQP,OCHdQ,IAASC,OACP,cAAC,IAAMC,WAAP,UACE,cAAC,EAAD,MAEFC,SAASC,eAAe,SAM1Bb,M","file":"static/js/main.cb5a70f4.chunk.js","sourcesContent":["import React, { ReactElement, useState, useEffect, useRef } from 'react';\r\nimport { transpileModule } from 'typescript';\r\nimport './index.css';\r\n\r\ninterface Props {\r\n\r\n}\r\n\r\ninterface cellPositionProperties {\r\n    isStart: boolean;\r\n    isEnd: boolean;\r\n    isTopRow: boolean;\r\n    isBottomRow: boolean;\r\n    isLeftCol: boolean;\r\n    isRightCol: boolean;\r\n}\r\n\r\ninterface cellMoveProperties {\r\n    canMoveUp: boolean;\r\n    canMoveRight: boolean;\r\n    canMoveDown: boolean;\r\n    canMoveLeft: boolean;\r\n}\r\n\r\ninterface cellProperties extends cellPositionProperties {\r\n}\r\n\r\nexport default function Maze({ }: Props): ReactElement {\r\n    const [mazeWidth, setMazeWidth] = useState<number>(10); // height is same as width\r\n    const [mazeCells, setMazeCellsState] = useState<any[]>([]);\r\n    const mazeCellsRef = useRef<any[]>([])\r\n    const setMazeCells = (data: any) => {\r\n        mazeCellsRef.current = data;\r\n        setMazeCellsState(data);\r\n    }\r\n\r\n    const [playerLocation, setPlayerLocationState] = useState<{ row: number; col: number }>({ row: 1, col: 1 })\r\n    const playerLocationRef = useRef<{ row: number; col: number }>({ row: 1, col: 1 })\r\n    const setPlayerLocation = (data: { row: number, col: number }) => {\r\n        playerLocationRef.current = data;\r\n        setPlayerLocationState(data);\r\n    }\r\n\r\n    const playerIcon = useRef<null | HTMLDivElement>(null);\r\n\r\n    useEffect(() => {\r\n        generateCells();\r\n\r\n        // create event listener to move player\r\n        window.addEventListener('keydown', handleKeyPress)\r\n    }, [])\r\n\r\n    const generateCells: () => void = () => {\r\n\r\n        let nums: cellPositionProperties[] = [];\r\n\r\n        // iterate over all cells in maze\r\n        for (let i = 1; i <= mazeWidth ** 2; i++) {\r\n            const cellObj: cellPositionProperties = {\r\n                isStart: i === 1,\r\n                isEnd: i === mazeWidth ** 2,\r\n                isBottomRow: i > mazeWidth ** 2 - mazeWidth,\r\n                isRightCol: i % mazeWidth === 0,\r\n                isLeftCol: i === 1 || (i - 1) % mazeWidth === 0,\r\n                isTopRow: i <= mazeWidth\r\n            }\r\n\r\n            // push object for cell to array of cells\r\n            nums.push(cellObj);\r\n        }\r\n\r\n        // createSimplePath(nums)\r\n        // createRandomSimplePath(nums)\r\n        // createSimpleLeftAndUpPath(nums);\r\n        createPathWithoutVisitingCellsTwice(nums);\r\n\r\n        setMazeCells(nums)\r\n    }\r\n\r\n    // simple path to understand logic of game and test user movements\r\n    const createSimplePath = (cells: any[]) => {\r\n        cells.forEach((cell, index) => {\r\n            const cellNumb = index + 1;\r\n\r\n            if (cell.isTopRow) {\r\n                if (!cell.isRightCol) cell.canMoveRight = true;\r\n                if (!cell.isStart) cell.canMoveLeft = true;\r\n            }\r\n            if (cell.isRightCol) {\r\n                if (!cell.isEnd) cell.canMoveDown = true;\r\n                if (!cell.isTopRow) cell.canMoveUp = true;\r\n            }\r\n        })\r\n    }\r\n\r\n    const createRandomSimplePath = (cells: any[]) => {\r\n        const totalMoves = []\r\n        // push total number of right and down moves needed to reach end\r\n        for (let i = 0; i < mazeWidth - 1; i++) {\r\n            totalMoves.push('right');\r\n            totalMoves.push('down')\r\n        }\r\n\r\n        let currentCellIndex = 0;\r\n\r\n        while (totalMoves.length > 0) {\r\n            const currentCell = cells[currentCellIndex];\r\n\r\n            const randomIndex = Math.floor(Math.random() * totalMoves.length)\r\n\r\n            const move = totalMoves[randomIndex]\r\n            totalMoves.splice(randomIndex, 1);\r\n\r\n            switch (move) {\r\n                case 'right':\r\n                    currentCell.canMoveRight = true;\r\n                    currentCellIndex += 1;\r\n                    cells[currentCellIndex].canMoveLeft = true;\r\n                    break;\r\n                case 'down':\r\n                    currentCell.canMoveDown = true;\r\n                    currentCellIndex += mazeWidth;\r\n                    cells[currentCellIndex].canMoveUp = true;\r\n                    break;\r\n            }\r\n        }\r\n    }\r\n\r\n    // implements left and up moves but won't likely reach end\r\n    const createSimpleLeftAndUpPath = (cells: any[]) => {\r\n        const totalMoves = []\r\n        // push total number of right and down moves needed to reach end\r\n        for (let i = 0; i < mazeWidth - 1; i++) {\r\n            totalMoves.push('right');\r\n            totalMoves.push('down')\r\n        }\r\n        console.log(totalMoves)\r\n\r\n        let currentCellIndex = 0;\r\n\r\n        for (let i = 0; i < (mazeWidth ** 2 - 2); i++) {\r\n            const currentCell = cells[currentCellIndex];\r\n\r\n            const randomIndex = Math.floor(Math.random() * totalMoves.length)\r\n\r\n            const move = totalMoves[randomIndex]\r\n            totalMoves.splice(randomIndex, 1);\r\n\r\n            switch (move) {\r\n                case 'right':\r\n                    currentCell.canMoveRight = true;\r\n                    currentCellIndex += 1;\r\n                    cells[currentCellIndex].canMoveLeft = true;\r\n                    totalMoves.push('left') // push opposite move to array of moves\r\n                    break;\r\n                case 'down':\r\n                    currentCell.canMoveDown = true;\r\n                    currentCellIndex += mazeWidth;\r\n                    cells[currentCellIndex].canMoveUp = true;\r\n                    totalMoves.push('up')\r\n                    break;\r\n                case 'up':\r\n                    currentCell.canMoveUp = true;\r\n                    currentCellIndex -= mazeWidth;\r\n                    cells[currentCellIndex].canMoveDown = true;\r\n                    totalMoves.push('down')\r\n                    break;\r\n                case 'left':\r\n                    currentCell.canMoveLeft = true;\r\n                    currentCellIndex -= 1;\r\n                    cells[currentCellIndex].canMoveRight = true;\r\n                    totalMoves.push('right')\r\n                    break;\r\n            }\r\n        }\r\n    }\r\n\r\n    // this path avoids visiting the same cell twice\r\n    const createPathWithoutVisitingCellsTwice = (cells: any[]) => {\r\n        const validMoves = ['up', 'down', 'left', 'right'];\r\n\r\n        const remainingMoves = {\r\n            right: mazeWidth - 1,\r\n            down: mazeWidth - 1,\r\n            left: 0,\r\n            top: 0\r\n        }\r\n\r\n\r\n        let currentIndex = 0;\r\n\r\n        // iterate over cells' upper limit of all cells minus start and end\r\n        for (let i = 0; i < (mazeWidth ** 2 - 2); i++) {\r\n            const nextMoves = [] // valid moves for each iteration\r\n            let currentCell = cells[currentIndex]\r\n            // console.log(currentCell)\r\n\r\n            // for each valid move (up down left and right) check if the move is valid\r\n            for (let move of validMoves) {\r\n                let nextCell = null;\r\n\r\n                switch (move) {\r\n                    case 'up':\r\n                        if (!currentCell.isTopRow) nextCell = cells[currentIndex - mazeWidth];\r\n                        break;\r\n                    case 'right':\r\n                        if (!currentCell.isRightCol) nextCell = cells[currentIndex + 1];\r\n                        break;\r\n                    case 'down':\r\n                        if (!currentCell.isBottomRow) nextCell = cells[currentIndex + mazeWidth];\r\n                        break;\r\n                    case 'left':\r\n                        if (!currentCell.isLeftCol) nextCell = cells[currentIndex - 1];\r\n                        break;\r\n                }\r\n\r\n                // if there is a cell in that direction that hasn't been visited\r\n                if (nextCell && !nextCell.hasBeenVisited) {\r\n                    // add that direction as a valid next move\r\n                    nextMoves.push(move);\r\n                }\r\n            }\r\n\r\n            // randomly choose one of the valid directions to move\r\n            const randomInt = Math.floor(Math.random() * nextMoves.length)\r\n            const randomMove = nextMoves[randomInt];\r\n            if (nextMoves.length > 0) {\r\n                // update cell's direction properties and move on to that cell\r\n                switch (randomMove) {\r\n                    case 'up':\r\n                        currentCell.canMoveUp = true;\r\n                        currentIndex -= mazeWidth;\r\n                        console.log(currentIndex)\r\n                        cells[currentIndex].canMoveDown = true;\r\n                        break;\r\n                    case 'right':\r\n                        currentCell.canMoveRight = true;\r\n                        currentIndex += 1;\r\n                        cells[currentIndex].canMoveLeft = true;\r\n                        break;\r\n                    case 'down':\r\n                        currentCell.canMoveDown = true;\r\n                        currentIndex += mazeWidth;\r\n                        cells[currentIndex].canMoveUp = true;\r\n                        break;\r\n                    case 'left':\r\n                        currentCell.canMoveLeft = true;\r\n                        currentIndex -= 1;\r\n                        cells[currentIndex].canMoveRight = true;\r\n                        break;\r\n                }\r\n            }\r\n\r\n            currentCell.hasBeenVisited = true;\r\n            console.log('iteration over')\r\n        }\r\n    }\r\n\r\n    const handleKeyPress = (e: KeyboardEvent) => {\r\n        // return early if player icon has not been loaded in yet\r\n        if (!playerIcon) return\r\n\r\n        switch (e.key.toLowerCase()) {\r\n            case 'w':\r\n            case 'arrowup':\r\n                moveUp();\r\n                break;\r\n            case 'a':\r\n            case 'arrowleft':\r\n                moveLeft();\r\n                break;\r\n            case 's':\r\n            case 'arrowdown':\r\n                moveDown();\r\n                break;\r\n            case \"d\":\r\n            case \"arrowright\":\r\n                moveRight();\r\n                break;\r\n        }\r\n    }\r\n\r\n    const getCellIndexByLocation = (location: { row: number, col: number }) => {\r\n        const cellIndex = (location.row - 1) * mazeWidth + location.col - 1\r\n        return mazeCellsRef.current[cellIndex];\r\n    }\r\n\r\n    const moveUp = () => {\r\n        const cell = getCellIndexByLocation(playerLocationRef.current)\r\n\r\n        if (playerLocationRef.current.row === 1 || !cell.canMoveUp) return\r\n\r\n        setPlayerLocation({ ...playerLocationRef.current, row: playerLocationRef.current.row - 1 })\r\n    }\r\n\r\n    const moveRight = () => {\r\n        const cell = getCellIndexByLocation(playerLocationRef.current)\r\n\r\n        if (playerLocationRef.current.col >= mazeWidth || !cell.canMoveRight) return\r\n\r\n        setPlayerLocation({ ...playerLocationRef.current, col: playerLocationRef.current.col + 1 })\r\n    }\r\n\r\n    const moveLeft = () => {\r\n        const cell = getCellIndexByLocation(playerLocationRef.current)\r\n\r\n        if (playerLocationRef.current.col === 1 || !cell.canMoveLeft) return\r\n\r\n        setPlayerLocation({ ...playerLocationRef.current, col: playerLocationRef.current.col - 1 })\r\n    }\r\n\r\n    const moveDown = () => {\r\n        const cell = getCellIndexByLocation(playerLocationRef.current)\r\n\r\n        if (playerLocationRef.current.row >= mazeWidth || !cell.canMoveDown) return\r\n\r\n        setPlayerLocation({ ...playerLocationRef.current, row: playerLocationRef.current.row + 1 })\r\n    }\r\n\r\n    return (\r\n        <div className='maze-aspect-ratio-wrapper'>\r\n            <div className='maze-wrapper-outer'>\r\n                <div className='maze-wrapper-inner'>\r\n                    <div\r\n                        ref={playerIcon}\r\n                        className='player-wrapper'\r\n                        style={{ top: `${(playerLocation.row - 1) * (100 / mazeWidth)}%`, left: `${(playerLocation.col - 1) * (100 / mazeWidth)}%`, width: `${100 / mazeWidth}%`, height: `${100 / mazeWidth}%` }}>\r\n                        <div className='player'></div>\r\n                    </div>\r\n                    {mazeCells.map((cell, i) => {\r\n                        return (\r\n                            <div\r\n                                className={`maze-cell${cell.isStart ? ' start' : ''}${cell.isEnd ? ' end' : ''}${cell.isRightCol ? ' right-col' : ''}${cell.isBottomRow ? ' bottom-row' : ''}${cell.canMoveUp ? ' can-move-up' : ''}${cell.canMoveRight ? ' can-move-right' : ''}${cell.canMoveDown ? ' can-move-down' : ''}${cell.canMoveLeft ? ' can-move-left' : ''}`}\r\n                                style={{ width: `${100 / mazeWidth}%`, height: `${100 / mazeWidth}%` }}\r\n                                key={i}>\r\n                            </div>\r\n                        )\r\n                    })}\r\n                </div>\r\n            </div>\r\n        </div>\r\n    )\r\n}\r\n","import React, { ReactElement } from 'react'\r\nimport Maze from '../../components/Maze'\r\nimport './index.css'\r\n\r\nexport default function Game(): ReactElement {\r\n    return (\r\n        <>\r\n            <Maze />\r\n        </>\r\n    )\r\n}\r\n","import React from 'react';\nimport './App.css';\nimport { BrowserRouter as Router, Switch, Route } from 'react-router-dom';\nimport Game from './pages/Game';\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <Router basename='/maze-game'>\n        <Switch>\n          <Route exact path='/'>\n            <Game />\n          </Route>\n        </Switch>\n      </Router>\n    </div>\n  );\n}\n\nexport default App;\n","import { ReportHandler } from 'web-vitals';\n\nconst reportWebVitals = (onPerfEntry?: ReportHandler) => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}