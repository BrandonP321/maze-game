{"version":3,"sources":["components/Maze/mobileControls.ts","components/Maze/index.tsx","pages/Game/index.tsx","pages/Home/index.tsx","App.tsx","reportWebVitals.ts","index.tsx"],"names":["isSwiping","startPosition","handleScreenTouch","e","position","x","changedTouches","pageX","y","pageY","handleSwipe","preventDefault","Maze","difficulty","useParams","useState","mazeWidth","mazeCells","setMazeCellsState","mazeCellsRef","useRef","row","col","playerLocation","setPlayerLocationState","playerLocationRef","setPlayerLocation","data","current","playerIcon","useEffect","generateCells","window","addEventListener","handleKeyPress","document","directionToMove","slope","handleScreenTouchEnd","moveUp","moveDown","moveRight","moveLeft","alert","nums","i","cellObj","isStart","isEnd","isBottomRow","isRightCol","isLeftCol","isTopRow","push","createPath","cells","validMoves","remainingMoves","right","down","left","up","visitedCells","currentIndex","loopLimit","hasReachedEnd","nextMoves","currentCell","move","nextCell","hasBeenVisited","randomMove","Math","floor","random","length","generateWeightedRandomMove","canMoveUp","canMoveDown","canMoveRight","canMoveLeft","shift","endCellIndex","endCell","cellAboveEnd","possibleMoves","weightedArr","movesCount","Array","fill","key","toLowerCase","getCellByLocation","location","cellIndex","cell","className","ref","style","top","width","height","map","Game","Home","to","App","basename","exact","path","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","getElementById"],"mappings":"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","file":"static/js/main.d8b7712b.chunk.js","sourcesContent":["import React from 'react'\r\nimport { isIfStatement } from 'typescript';\r\n\r\nlet isSwiping = false;\r\nlet startPosition: (null | { x: number; y: number }) = null;\r\n\r\n// when user first touches screen\r\nexport const handleScreenTouch = (e: TouchEvent) => {\r\n    let position = {\r\n        x: e.changedTouches[0].pageX,\r\n        y: e.changedTouches[0].pageY,\r\n    }\r\n    startPosition = position;\r\n}\r\n\r\n// when user is moving their finger on the screen\r\nexport const handleSwipe = (e: TouchEvent) => {\r\n    e.preventDefault();\r\n    isSwiping = true;\r\n}\r\n\r\n// when user takes their finger off the screen\r\nexport const handleScreenTouchEnd = (e: TouchEvent) => {\r\n    const position = {\r\n        x: e.changedTouches[0].pageX,\r\n        y: e.changedTouches[0].pageY\r\n    }\r\n    // if use wasn't swiping, return false\r\n    if (!isSwiping || !startPosition) return false\r\n\r\n    // calculating slope looks different due to smaller y values being at top of page\r\n    const slope = (position.y - startPosition.y) / (startPosition.x - position.x)\r\n    \r\n    isSwiping = false\r\n\r\n    if (slope <= -1 || slope >= 1) {\r\n        if (position.y < startPosition.y) return 'up'\r\n        else return 'down'\r\n    } else {\r\n        if (position.x > startPosition.x) return 'right'\r\n        else return 'left'\r\n    }\r\n\r\n}\r\n","import React, { ReactElement, useState, useEffect, useRef } from 'react';\r\nimport { useParams } from 'react-router';\r\nimport { transpileModule } from 'typescript';\r\nimport './index.scss';\r\nimport { handleScreenTouch, handleScreenTouchEnd, handleSwipe } from './mobileControls'\r\n\r\n\r\ninterface Props {\r\n\r\n}\r\n\r\ninterface cellPositionProperties {\r\n    isStart: boolean;\r\n    isEnd: boolean;\r\n    isTopRow: boolean;\r\n    isBottomRow: boolean;\r\n    isLeftCol: boolean;\r\n    isRightCol: boolean;\r\n}\r\n\r\ninterface cellMoveProperties {\r\n    canMoveUp: boolean;\r\n    canMoveRight: boolean;\r\n    canMoveDown: boolean;\r\n    canMoveLeft: boolean;\r\n}\r\n\r\ninterface cellProperties extends cellPositionProperties {\r\n}\r\n\r\nexport default function Maze({ }: Props): ReactElement {\r\n    const { difficulty } = useParams<any>()\r\n\r\n    const [mazeWidth, setMazeWidth] = useState<number>(difficulty === 'easy' ? 10 : difficulty === 'medium' ? 20 : 30); // height is same as width\r\n    const [mazeCells, setMazeCellsState] = useState<any[]>([]);\r\n    const mazeCellsRef = useRef<any[]>([])\r\n    const setMazeCells = (data: any) => {\r\n        mazeCellsRef.current = data;\r\n        setMazeCellsState(data);\r\n    }\r\n\r\n    const [playerLocation, setPlayerLocationState] = useState<{ row: number; col: number }>({ row: 1, col: 1 })\r\n    const playerLocationRef = useRef<{ row: number; col: number }>({ row: 1, col: 1 })\r\n    const setPlayerLocation = (data: { row: number, col: number }) => {\r\n        playerLocationRef.current = data;\r\n        setPlayerLocationState(data);\r\n    }\r\n\r\n    const playerIcon = useRef<null | HTMLDivElement>(null);\r\n\r\n    useEffect(() => {\r\n        generateCells();\r\n\r\n        // create event listener to move player\r\n        window.addEventListener('keydown', handleKeyPress)\r\n\r\n        // create event listener for when user swipes screen on mobile device\r\n        document.addEventListener('touchstart', handleScreenTouch)\r\n        document.addEventListener('touchmove', handleSwipe)\r\n        document.addEventListener('touchend', e => {\r\n            const directionToMove = handleScreenTouchEnd(e)\r\n\r\n            if (!directionToMove) return\r\n\r\n            switch (directionToMove) {\r\n                case 'up':\r\n                    moveUp();\r\n                    break;\r\n                case 'down':\r\n                    moveDown();\r\n                    break;\r\n                case \"right\":\r\n                    moveRight();\r\n                    break;\r\n                case 'left':\r\n                    moveLeft();\r\n                    break;\r\n            }\r\n        })\r\n    }, [])\r\n\r\n    useEffect(() => {\r\n        // check if player has reached end when they move\r\n        if (playerLocation.col === mazeWidth && playerLocation.row === mazeWidth) {\r\n            alert(\"You win\")\r\n        }\r\n    }, [playerLocation])\r\n\r\n    const generateCells: () => void = () => {\r\n\r\n        let nums: cellPositionProperties[] = [];\r\n\r\n        // iterate over all cells in maze\r\n        for (let i = 1; i <= mazeWidth ** 2; i++) {\r\n            const cellObj: cellPositionProperties = {\r\n                isStart: i === 1,\r\n                isEnd: i === mazeWidth ** 2,\r\n                isBottomRow: i > mazeWidth ** 2 - mazeWidth,\r\n                isRightCol: i % mazeWidth === 0,\r\n                isLeftCol: i === 1 || (i - 1) % mazeWidth === 0,\r\n                isTopRow: i <= mazeWidth\r\n            }\r\n\r\n            // push object for cell to array of cells\r\n            nums.push(cellObj);\r\n        }\r\n\r\n        // createSimplePath(nums)\r\n        // createRandomSimplePath(nums)\r\n        // createSimpleLeftAndUpPath(nums);\r\n        // createPathWithoutVisitingCellsTwice(nums);\r\n        createPath(nums);\r\n\r\n        setMazeCells(nums)\r\n    }\r\n\r\n    // simple path to understand logic of game and test user movements\r\n    const createSimplePath = (cells: any[]) => {\r\n        cells.forEach((cell, index) => {\r\n            const cellNumb = index + 1;\r\n\r\n            if (cell.isTopRow) {\r\n                if (!cell.isRightCol) cell.canMoveRight = true;\r\n                if (!cell.isStart) cell.canMoveLeft = true;\r\n            }\r\n            if (cell.isRightCol) {\r\n                if (!cell.isEnd) cell.canMoveDown = true;\r\n                if (!cell.isTopRow) cell.canMoveUp = true;\r\n            }\r\n        })\r\n    }\r\n\r\n    const createRandomSimplePath = (cells: any[]) => {\r\n        const totalMoves = []\r\n        // push total number of right and down moves needed to reach end\r\n        for (let i = 0; i < mazeWidth - 1; i++) {\r\n            totalMoves.push('right');\r\n            totalMoves.push('down')\r\n        }\r\n\r\n        let currentCellIndex = 0;\r\n\r\n        while (totalMoves.length > 0) {\r\n            const currentCell = cells[currentCellIndex];\r\n\r\n            const randomIndex = Math.floor(Math.random() * totalMoves.length)\r\n\r\n            const move = totalMoves[randomIndex]\r\n            totalMoves.splice(randomIndex, 1);\r\n\r\n            switch (move) {\r\n                case 'right':\r\n                    currentCell.canMoveRight = true;\r\n                    currentCellIndex += 1;\r\n                    cells[currentCellIndex].canMoveLeft = true;\r\n                    break;\r\n                case 'down':\r\n                    currentCell.canMoveDown = true;\r\n                    currentCellIndex += mazeWidth;\r\n                    cells[currentCellIndex].canMoveUp = true;\r\n                    break;\r\n            }\r\n        }\r\n    }\r\n\r\n    // implements left and up moves but won't likely reach end\r\n    const createSimpleLeftAndUpPath = (cells: any[]) => {\r\n        const totalMoves = []\r\n        // push total number of right and down moves needed to reach end\r\n        for (let i = 0; i < mazeWidth - 1; i++) {\r\n            totalMoves.push('right');\r\n            totalMoves.push('down')\r\n        }\r\n        console.log(totalMoves)\r\n\r\n        let currentCellIndex = 0;\r\n\r\n        for (let i = 0; i < (mazeWidth ** 2 - 2); i++) {\r\n            const currentCell = cells[currentCellIndex];\r\n\r\n            const randomIndex = Math.floor(Math.random() * totalMoves.length)\r\n\r\n            const move = totalMoves[randomIndex]\r\n            totalMoves.splice(randomIndex, 1);\r\n\r\n            switch (move) {\r\n                case 'right':\r\n                    currentCell.canMoveRight = true;\r\n                    currentCellIndex += 1;\r\n                    cells[currentCellIndex].canMoveLeft = true;\r\n                    totalMoves.push('left') // push opposite move to array of moves\r\n                    break;\r\n                case 'down':\r\n                    currentCell.canMoveDown = true;\r\n                    currentCellIndex += mazeWidth;\r\n                    cells[currentCellIndex].canMoveUp = true;\r\n                    totalMoves.push('up')\r\n                    break;\r\n                case 'up':\r\n                    currentCell.canMoveUp = true;\r\n                    currentCellIndex -= mazeWidth;\r\n                    cells[currentCellIndex].canMoveDown = true;\r\n                    totalMoves.push('down')\r\n                    break;\r\n                case 'left':\r\n                    currentCell.canMoveLeft = true;\r\n                    currentCellIndex -= 1;\r\n                    cells[currentCellIndex].canMoveRight = true;\r\n                    totalMoves.push('right')\r\n                    break;\r\n            }\r\n        }\r\n    }\r\n\r\n    // this path avoids visiting the same cell twice\r\n    const createPathWithoutVisitingCellsTwice = (cells: any[]) => {\r\n        const validMoves = ['up', 'down', 'left', 'right'];\r\n\r\n        const remainingMoves = {\r\n            right: mazeWidth - 1,\r\n            down: mazeWidth - 1,\r\n            left: 0,\r\n            up: 0\r\n        }\r\n\r\n\r\n        let currentIndex = 0;\r\n\r\n        // iterate over cells' upper limit of all cells minus start and end\r\n        for (let i = 0; i < (mazeWidth ** 2 - 2); i++) {\r\n            const nextMoves = [] // valid moves for each iteration\r\n            let currentCell = cells[currentIndex]\r\n\r\n            // for each valid move (up down left and right) check if the move is valid\r\n            for (let move of validMoves) {\r\n                let nextCell = null;\r\n\r\n                switch (move) {\r\n                    case 'up':\r\n                        if (!currentCell.isTopRow) nextCell = cells[currentIndex - mazeWidth];\r\n                        break;\r\n                    case 'right':\r\n                        if (!currentCell.isRightCol) nextCell = cells[currentIndex + 1];\r\n                        break;\r\n                    case 'down':\r\n                        if (!currentCell.isBottomRow) nextCell = cells[currentIndex + mazeWidth];\r\n                        break;\r\n                    case 'left':\r\n                        if (!currentCell.isLeftCol) nextCell = cells[currentIndex - 1];\r\n                        break;\r\n                }\r\n\r\n                // if there is a cell in that direction that hasn't been visited\r\n                if (nextCell && !nextCell.hasBeenVisited) {\r\n                    // add that direction as a valid next move\r\n                    nextMoves.push(move);\r\n                }\r\n            }\r\n\r\n            // randomly choose one of the valid directions to move\r\n            const randomInt = Math.floor(Math.random() * nextMoves.length)\r\n            const randomMove = nextMoves[randomInt];\r\n\r\n\r\n            // if there are no possible moves, break out of for loop since there is nowhere left to go\r\n            if (nextMoves.length === 0) break;\r\n\r\n            // update cell's direction properties and move on to that cell\r\n            switch (randomMove) {\r\n                case 'up':\r\n                    currentCell.canMoveUp = true;\r\n                    currentIndex -= mazeWidth;\r\n                    cells[currentIndex].canMoveDown = true;\r\n                    remainingMoves.up--;\r\n                    remainingMoves.down++;\r\n                    break;\r\n                case 'right':\r\n                    currentCell.canMoveRight = true;\r\n                    currentIndex += 1;\r\n                    cells[currentIndex].canMoveLeft = true;\r\n                    remainingMoves.right--;\r\n                    remainingMoves.left++;\r\n                    break;\r\n                case 'down':\r\n                    currentCell.canMoveDown = true;\r\n                    currentIndex += mazeWidth;\r\n                    cells[currentIndex].canMoveUp = true;\r\n                    remainingMoves.down--;\r\n                    remainingMoves.up++;\r\n                    break;\r\n                case 'left':\r\n                    currentCell.canMoveLeft = true;\r\n                    currentIndex -= 1;\r\n                    cells[currentIndex].canMoveRight = true;\r\n                    remainingMoves.left--;\r\n                    remainingMoves.right++;\r\n                    break;\r\n            }\r\n\r\n            currentCell.hasBeenVisited = true;\r\n            console.log('iteration over')\r\n        }\r\n    }\r\n\r\n    // create path from start cell to end cell\r\n    const createPath = (cells: any[]) => {\r\n        const validMoves = ['up', 'down', 'left', 'right'];\r\n\r\n        const remainingMoves = {\r\n            right: mazeWidth - 1,\r\n            down: mazeWidth - 1,\r\n            left: 0,\r\n            up: 0\r\n        }\r\n\r\n        const visitedCells: number[] = []\r\n\r\n        let currentIndex: any = 0;\r\n\r\n        let loopLimit = mazeWidth ** 2 - 2\r\n\r\n        let hasReachedEnd = false;\r\n\r\n        // iterate over cells' upper limit of all cells minus start and end\r\n        for (let i = 0; i < loopLimit; i++) {\r\n            const nextMoves = [] // valid moves for each iteration\r\n            let currentCell = cells[currentIndex]\r\n\r\n            // for each valid move (up down left and right) check if the move is valid\r\n            for (let move of validMoves) {\r\n                let nextCell = null;\r\n\r\n                // if we are in the end cell, don't create path from here\r\n                if (currentCell.isEnd) {\r\n                    hasReachedEnd = true;\r\n                    break;\r\n                }\r\n\r\n                switch (move) {\r\n                    case 'up':\r\n                        if (!currentCell.isTopRow) nextCell = cells[currentIndex - mazeWidth];\r\n                        break;\r\n                    case 'right':\r\n                        if (!currentCell.isRightCol) nextCell = cells[currentIndex + 1];\r\n                        break;\r\n                    case 'down':\r\n                        if (!currentCell.isBottomRow) nextCell = cells[currentIndex + mazeWidth];\r\n                        break;\r\n                    case 'left':\r\n                        if (!currentCell.isLeftCol) nextCell = cells[currentIndex - 1];\r\n                        break;\r\n                }\r\n\r\n                // if there is a cell in that direction that hasn't been visited\r\n                if (nextCell && !nextCell.hasBeenVisited) {\r\n                    // add that direction as a valid next move\r\n                    nextMoves.push(move);\r\n                }\r\n            }\r\n            \r\n            let randomMove;\r\n            // if user has reached end\r\n            if (hasReachedEnd) {\r\n                // generate completely random direction to move\r\n                const randomInt = Math.floor(Math.random() * nextMoves.length)\r\n                randomMove = nextMoves[randomInt]\r\n            } else {\r\n                // generate weighted random direction to move\r\n                randomMove = generateWeightedRandomMove(remainingMoves, nextMoves) // generates move based on weighted object of moves needed\r\n            }\r\n            \r\n            currentCell.hasBeenVisited = true;\r\n            // if there are no possible moves\r\n            if (nextMoves.length === 0) {\r\n                // move backwards in array of visited cells\r\n                currentIndex = visitedCells.shift();\r\n                loopLimit++\r\n                continue\r\n            }\r\n\r\n            // update cell's direction properties and move on to that cell\r\n            switch (randomMove) {\r\n                case 'up':\r\n                    currentCell.canMoveUp = true;\r\n                    currentIndex -= mazeWidth;\r\n                    cells[currentIndex].canMoveDown = true;\r\n                    remainingMoves.up--;\r\n                    remainingMoves.down++;\r\n                    break;\r\n                case 'right':\r\n                    currentCell.canMoveRight = true;\r\n                    currentIndex += 1;\r\n                    cells[currentIndex].canMoveLeft = true;\r\n                    remainingMoves.right--;\r\n                    remainingMoves.left++;\r\n                    break;\r\n                case 'down':\r\n                    currentCell.canMoveDown = true;\r\n                    currentIndex += mazeWidth;\r\n                    cells[currentIndex].canMoveUp = true;\r\n                    remainingMoves.down--;\r\n                    remainingMoves.up++;\r\n                    break;\r\n                case 'left':\r\n                    currentCell.canMoveLeft = true;\r\n                    currentIndex -= 1;\r\n                    cells[currentIndex].canMoveRight = true;\r\n                    remainingMoves.left--;\r\n                    remainingMoves.right++;\r\n                    break;\r\n            }\r\n\r\n\r\n            visitedCells.push(currentIndex);\r\n        }\r\n\r\n        // if end cell has not been visited, remove border above it to create a valid path\r\n        if (!hasReachedEnd) {\r\n            const endCellIndex = mazeWidth ** 2 - 1\r\n            const endCell = cells[endCellIndex];\r\n            const cellAboveEnd = cells[endCellIndex - mazeWidth];\r\n            endCell.canMoveUp = true;\r\n            cellAboveEnd.canMoveDown = true;\r\n        }\r\n    }\r\n\r\n    \r\n    const generateWeightedRandomMove = (remainingMoves: any, possibleMoves: any[]) => {\r\n        let weightedArr = []\r\n        \r\n        for (let move of possibleMoves) {\r\n            // in the case that the remaining moves object has a value of 0, default that to 1\r\n            let movesCount = remainingMoves[move] === 0 ? 1 : remainingMoves\r\n\r\n            weightedArr.push(...new Array(movesCount).fill(move))\r\n        }\r\n        \r\n        // generate random index in weighted array\r\n        const randomInt = Math.floor(Math.random() * weightedArr.length);\r\n        return weightedArr[randomInt]\r\n    }\r\n    \r\n    const handleKeyPress = (e: KeyboardEvent) => {\r\n        // return early if player icon has not been loaded in yet\r\n        if (!playerIcon) return\r\n\r\n        switch (e.key.toLowerCase()) {\r\n            case 'w':\r\n            case 'arrowup':\r\n                moveUp();\r\n                break;\r\n            case 'a':\r\n            case 'arrowleft':\r\n                moveLeft();\r\n                break;\r\n            case 's':\r\n            case 'arrowdown':\r\n                moveDown();\r\n                break;\r\n            case \"d\":\r\n            case \"arrowright\":\r\n                moveRight();\r\n                break;\r\n        }\r\n    }\r\n\r\n    const getCellByLocation = (location: { row: number, col: number }) => {\r\n        const cellIndex = (location.row - 1) * mazeWidth + location.col - 1\r\n        return mazeCellsRef.current[cellIndex];\r\n    }\r\n\r\n    const moveUp = () => {\r\n        const cell = getCellByLocation(playerLocationRef.current)\r\n\r\n        if (playerLocationRef.current.row === 1 || !cell.canMoveUp) return\r\n\r\n        setPlayerLocation({ ...playerLocationRef.current, row: playerLocationRef.current.row - 1 })\r\n    }\r\n\r\n    const moveRight = () => {\r\n        const cell = getCellByLocation(playerLocationRef.current)\r\n\r\n        if (playerLocationRef.current.col >= mazeWidth || !cell.canMoveRight) return\r\n\r\n        setPlayerLocation({ ...playerLocationRef.current, col: playerLocationRef.current.col + 1 })\r\n    }\r\n\r\n    const moveLeft = () => {\r\n        const cell = getCellByLocation(playerLocationRef.current)\r\n\r\n        if (playerLocationRef.current.col === 1 || !cell.canMoveLeft) return\r\n\r\n        setPlayerLocation({ ...playerLocationRef.current, col: playerLocationRef.current.col - 1 })\r\n    }\r\n\r\n    const moveDown = () => {\r\n        const cell = getCellByLocation(playerLocationRef.current)\r\n\r\n        if (playerLocationRef.current.row >= mazeWidth || !cell.canMoveDown) return\r\n\r\n        setPlayerLocation({ ...playerLocationRef.current, row: playerLocationRef.current.row + 1 })\r\n    }\r\n\r\n    return (\r\n        <div className='maze-aspect-ratio-wrapper'>\r\n            <div className='maze-wrapper-outer'>\r\n                <div className='maze-wrapper-inner'>\r\n                    <div\r\n                        ref={playerIcon}\r\n                        className='player-wrapper'\r\n                        style={{ top: `${(playerLocation.row - 1) * (100 / mazeWidth)}%`, left: `${(playerLocation.col - 1) * (100 / mazeWidth)}%`, width: `${100 / mazeWidth}%`, height: `${100 / mazeWidth}%` }}>\r\n                        <div className='player'></div>\r\n                    </div>\r\n                    {mazeCells.map((cell, i) => {\r\n                        return (\r\n                            <div\r\n                                className={`maze-cell${cell.isStart ? ' start' : ''}${cell.isEnd ? ' end' : ''}${cell.isRightCol ? ' right-col' : ''}${cell.isBottomRow ? ' bottom-row' : ''}${cell.canMoveUp ? ' can-move-up' : ''}${cell.canMoveRight ? ' can-move-right' : ''}${cell.canMoveDown ? ' can-move-down' : ''}${cell.canMoveLeft ? ' can-move-left' : ''}`}\r\n                                style={{ width: `${100 / mazeWidth}%`, height: `${100 / mazeWidth}%` }}\r\n                                key={i}>\r\n                            </div>\r\n                        )\r\n                    })}\r\n                </div>\r\n            </div>\r\n        </div>\r\n    )\r\n}\r\n","import React, { ReactElement } from 'react'\r\nimport Maze from '../../components/Maze'\r\nimport './index.css'\r\n\r\nexport default function Game(): ReactElement {\r\n    return (\r\n        <>\r\n            <Maze />\r\n        </>\r\n    )\r\n}\r\n","import React, { ReactElement } from 'react'\r\nimport { Link } from 'react-router-dom'\r\nimport './index.scss'\r\n\r\ninterface Props {\r\n    \r\n}\r\n\r\nexport default function Home({}: Props): ReactElement {\r\n    return (\r\n        <div className='home-page'>\r\n            <h1>The Maze Game</h1>\r\n            <div className='buttons'>\r\n                <Link to='/game/easy'>Easy</Link>\r\n                <Link to='/game/medium'>Medium</Link>\r\n                <Link to='/game/hard'>Hard</Link>\r\n            </div>\r\n        </div >\r\n    )\r\n}\r\n","import React from 'react';\nimport './App.css';\nimport { BrowserRouter as Router, Switch, Route } from 'react-router-dom';\nimport Game from './pages/Game';\nimport Home from './pages/Home';\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <Router basename='/maze-game'>\n        <Switch>\n          <Route exact path='/'>\n            <Home />\n          </Route>\n          <Route exact path='/game/:difficulty'>\n            <Game />\n          </Route>\n        </Switch>\n      </Router>\n    </div>\n  );\n}\n\nexport default App;\n","import { ReportHandler } from 'web-vitals';\n\nconst reportWebVitals = (onPerfEntry?: ReportHandler) => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}